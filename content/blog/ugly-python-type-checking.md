---
title: "(Ugly) Python type checking"
date: "2008-01-15"
tags: ["python"]
slug: "ugly-python-type-checking"

---


<span>I like Python because of the explicitness of the syntax</span><br /><br /><div class="highlight"><pre><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span><br />    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><br /></pre></div><br /><br /><span>explicitness is good as it really leads to code that is understandable at one glance, but quick, tell me two types that the above function will work on ? <br /><br><b> int's and strings </b> </span><br /><br /><div class="highlight"><br /><pre><br /> >>> add(1,2)<br /> 3<br /> >>> add('hello ','world')<br /> hello world<br /></pre><br /></div><br /><br /><span>the above function works on both integers and strings only because both provide the special method <b>__add__</b> which gets called for the <b>+</b> operator. <br /><br />So does this lead to implicitness ? Not really, because you should know (from programming) that you can add integers together and concatenate strings together, Python just makes this <i> general </i> across types. <br /><br />If you wanted to say, restrict the types of the arguments to our add function above, you could do something like the following </span><br /><br /><div class="highlight"><pre><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span><br />    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">==</span><span class="nb">type</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">==</span><span class="nb">type</span><span class="p">(</span><span class="nb">str</span><span class="p">):</span><br />        <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><br /></pre></div><br /><br />Type checking is kind of ambiguous to me in a dynamic language. If i want to restrict the the ability of a function to only work with certain types or i don't know the types of the object im passing to a function then i have design issues (or no design at all). <br /><br />You could rewrite the above function to do the type checking using a decorator.<br /><br />EDIT: i didn't know if the following decorator was written by the original creators or not, but as i was pointed out it wasn't here is the original link <br /><br /><a href='https://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/454322'>Python Cookbook Recipe</a><br /><br /><div class="highlight"><pre><span class="k">def</span> <span class="nf">require</span><span class="p">(</span><span class="n">arg_name</span><span class="p">,</span> <span class="o">*</span><span class="n">allowed_types</span><span class="p">):</span><br />    <span class="k">def</span> <span class="nf">make_wrapper</span><span class="p">(</span><span class="n">f</span><span class="p">):</span><br />        <span class="k">if</span> <span class="nb">hasattr<<br //span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">&quot;wrapped_args&quot;</span><span class="p">):</span><br />            <span class="n">wrapped_args</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">&quot;wrapped_args&quot;</span><span class="p">)</span><br />        <span class="k">else</span><span class="p">:</span><br />            <span class="n">code</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">func_code</span><br />            <span class="n">wrapped_args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">code</span><span class="o">.</span><span class="n">co_varnames</span><br />                    <span class="p">[:</span><span class="n">code</span><span class="o">.</span><span class="n">co_argcount</span><span class="p">])</span><br /><br />        <span class="k">try</span><span class="p">:</span><br />            <span class="n">arg_index</span> <span class="o">=</span> <span class="n">wrapped_args</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">arg_name</span><span class="p">)</span><br />        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span><br />            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">,</span> <span class="n">arg_name</span><br /><br />        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span><br />            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">arg_index</span><span class="p">:</span><br />                <span class="n">arg</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">arg_index</span><span class="p">]</span><br />            <span class="k">else</span><span class="p">:</span><br />                <span class="n">arg</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">arg_name</span><span class="p">]</span><br /><br />            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">allowed_types</span><span class="p">):</span><br />                <span class="n">type_list</span> <span class="o">=</span> <span class="s">&quot; or &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s">&quot;&#39;&quot;</span> <br />                        <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">allowed_type</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span> <span class="o">+</span> <br />                        <span class="s">&quot;&#39;&quot;</span> <span class="k">for</span> <span class="n">allowed_type</span> <span class="ow">in</span> <span class="n">allowed_types</span><span class="p">)</span><br />                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">,</span> <span class="s">&quot;Expected argument &#39;</span><span class="si">%s</span><span class="s">&#39; </span><span class="se">\</span><br /><span class="s">                   to be of type </span><span class="si">%s</span><span class="s"> but it was of type &#39;</span><span class="si">%s</span><span class="s">&#39;.&quot;</span> \<br />                   <span class="o">%</span> <span class="p">(</span><span class="n">arg_name</span><span class="p">,</span> <span class="n">type_list</span><span class="p">,</span><br />                      <span class="n">arg</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span><br /><br />            <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><br /><br />        <span class="n">wrapper</span><span class="o">.</span><span class="n">wrapped_args</span> <span class="o">=</span> <span class="n">wrapped_args</span><br />        <span class="k">return</span> <span class="n">wrapper</span><br /><br />    <span class="k">return</span> <span class="n">make_wrapper</span><br /><br /><span class="nd">@require</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span><span class="nb">str</span><span class="p">)</span><br /><span class="nd">@require</span><span class="p">(</span><span class="s">&#39;b&#39;</span><span class="p">,</span><span class="nb">str</span><span class="p">)</span><br /><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span><br />    <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><br /></pre></div><br /><br /><div><br /><pre><br />>>>add('hello ','world')<br />hello world<br />>>>add('hello',1)<br />Traceback (most recent call last):<br />  File "snippet3.py", line 38, in <module><br />    print add('hello',2)<br />  File "snippet3.py", line 24, in wrapper<br />    return f(*args, **kwargs)<br />  File "snippet3.py", line 22, in wrapper<br />    raise TypeError, "Expected argument '%s' to be of type %s <br />      but it was of type '%s'." % (arg_name,<br />      type_list, arg.__class__.__name__)<br />TypeError: Expected argument 'b' to be of type <br />           'str' but it was of type 'int'.<br /></pre><br /></div><br /><br /><span>above is code that does type checking on input arguments. I may be wrong and there may be use cases where you need to check the type of an object but the point is you should design your program so that you know all the involved types or use a language that has compile time type-checking.<br /><br />Note: The above type checking is in a Django application that is live and it has users and i didn't write that decorator.</span><br /><br /><br />
